<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MarkupEngine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jbake-core</a> &gt; <a href="index.source.html" class="el_package">org.jbake.parser</a> &gt; <span class="el_source">MarkupEngine.java</span></div><h1>MarkupEngine.java</h1><pre class="source lang-java linenums">package org.jbake.parser;

import org.apache.commons.configuration.CompositeConfiguration;
import org.apache.commons.configuration.Configuration;
import org.apache.commons.io.IOUtils;
import org.jbake.app.Crawler;
import org.jbake.app.configuration.DefaultJBakeConfiguration;
import org.jbake.app.configuration.JBakeConfiguration;
import org.json.simple.JSONValue;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * Base class for markup engine wrappers. A markup engine is responsible for rendering
 * markup in a source file and exporting the result into the {@link ParserContext#getDocumentModel() contents} map.
 * &lt;p&gt;
 * This specific engine does nothing, meaning that the body is rendered as raw contents.
 *
 * @author CÃ©dric Champeau
 */
<span class="fc" id="L32">public abstract class MarkupEngine implements ParserEngine {</span>
<span class="fc" id="L33">    private static final Logger LOGGER = LoggerFactory.getLogger(MarkupEngine.class);</span>
    private static final String UTF_8_BOM = &quot;\uFEFF&quot;;

    private JBakeConfiguration configuration;

    /**
     * Tests if this markup engine can process the document.
     *
     * @param context the parser context
     * @return true if this markup engine has enough context to process this document. false otherwise
     */
    public boolean validate(ParserContext context) {
<span class="fc" id="L45">        return true;</span>
    }

    /**
     * Processes the document header. Usually subclasses will parse the document body and look for
     * specific header metadata and export it into {@link ParserContext#getDocumentModel() contents} map.
     *
     * @param context the parser context
     */
    public void processHeader(final ParserContext context) {
<span class="fc" id="L55">    }</span>

    /**
     * Processes the body of the document. Usually subclasses will parse the document body and render
     * it, exporting the result using the {@link org.jbake.parser.ParserContext#setBody(String)} method.
     *
     * @param context the parser context
     */
    public void processBody(final ParserContext context) {
<span class="fc" id="L64">    }</span>

    @Override
    public Map&lt;String, Object&gt; parse(Configuration config, File file, String contentPath) {
<span class="nc" id="L68">        return parse(new DefaultJBakeConfiguration((CompositeConfiguration) config), file);</span>
    }

    /**
     * Parse given file to extract as much infos as possible
     *
     * @param file file to process
     * @return a map containing all infos. Returning null indicates an error, even if an exception would be better.
     */
    public Map&lt;String, Object&gt; parse(JBakeConfiguration config, File file) {
<span class="fc" id="L78">        this.configuration = config;</span>
        List&lt;String&gt; fileContents;
<span class="fc" id="L80">        try (InputStream is = new FileInputStream(file)) {</span>

<span class="fc" id="L82">            fileContents = IOUtils.readLines(is, config.getRenderEncoding());</span>
<span class="nc" id="L83">        } catch (IOException e) {</span>
<span class="nc" id="L84">            LOGGER.error(&quot;Error while opening file {}&quot;, file, e);</span>

<span class="nc" id="L86">            return null;</span>
<span class="fc" id="L87">        }</span>

<span class="fc" id="L89">        boolean hasHeader = hasHeader(fileContents);</span>
<span class="fc" id="L90">        ParserContext context = new ParserContext(</span>
                file,
                fileContents,
                config,
                hasHeader
        );

<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (hasHeader) {</span>
            // read header from file
<span class="fc" id="L99">            processDefaultHeader(context);</span>
        }
        // then read engine specific headers
<span class="fc" id="L102">        processHeader(context);</span>

<span class="fc" id="L104">        setModelDefaultsIfNotSetInHeader(context);</span>
<span class="fc" id="L105">        sanitizeTags(context);</span>

<span class="fc bfc" id="L107" title="All 4 branches covered.">        if (context.getType().isEmpty() || context.getStatus().isEmpty()) {</span>
            // output error
<span class="fc" id="L109">            LOGGER.warn(&quot;Parsing skipped (missing type or status value in header meta data) for file {}!&quot;, file);</span>
<span class="fc" id="L110">            return null;</span>
        }

        // generate default body
<span class="fc" id="L114">        processDefaultBody(context);</span>

        // eventually process body using specific engine
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">        if (validate(context)) {</span>
<span class="fc" id="L118">            processBody(context);</span>
        } else {
<span class="nc" id="L120">            LOGGER.error(&quot;Incomplete source file ({}) for markup engine: {}&quot;, file, getClass().getSimpleName());</span>
<span class="nc" id="L121">            return null;</span>
        }
        // TODO: post parsing plugins to hook in here?

<span class="fc" id="L125">        return context.getDocumentModel();</span>
    }

    private void sanitizeTags(ParserContext context) {
<span class="fc bfc" id="L129" title="All 2 branches covered.">        if (context.getTags() != null) {</span>
<span class="fc" id="L130">            String[] tags = (String[]) context.getTags();</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            for (int i = 0; i &lt; tags.length; i++) {</span>
<span class="fc" id="L132">                tags[i] = sanitizeValue(tags[i]);</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">                if (context.getConfig().getSanitizeTag()) {</span>
<span class="nc" id="L134">                    tags[i] = tags[i].replace(&quot; &quot;, &quot;-&quot;);</span>
                }
            }
<span class="fc" id="L137">            context.setTags(tags);</span>
        }
<span class="fc" id="L139">    }</span>

    private void setModelDefaultsIfNotSetInHeader(ParserContext context) {
<span class="fc bfc" id="L142" title="All 2 branches covered.">        if (context.getDate() == null) {</span>
<span class="fc" id="L143">            context.setDate(new Date(context.getFile().lastModified()));</span>
        }

        // default status has been set
<span class="pc bpc" id="L147" title="1 of 4 branches missed.">        if (context.getConfig().getDefaultStatus() != null &amp;&amp; context.getStatus().isEmpty()) {</span>
            // file hasn't got status so use default
<span class="fc" id="L149">            context.setDefaultStatus();</span>
        }

        // default type has been set
<span class="pc bpc" id="L153" title="1 of 4 branches missed.">        if (context.getConfig().getDefaultType() != null &amp;&amp; context.getType().isEmpty()) {</span>
            // file hasn't got type so use default
<span class="fc" id="L155">            context.setDefaultType();</span>
        }
<span class="fc" id="L157">    }</span>

    /**
     * Checks if the file has a meta-data header.
     *
     * @param contents Contents of file
     * @return true if header exists, false if not
     */
    private boolean hasHeader(List&lt;String&gt; contents) {
<span class="fc" id="L166">        boolean headerValid = true;</span>
<span class="fc" id="L167">        boolean statusFound = false;</span>
<span class="fc" id="L168">        boolean typeFound = false;</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if (!headerSeparatorDemarcatesHeader(contents)) {</span>
<span class="fc" id="L171">            return false;</span>
        }

<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        for (String line : contents) {</span>
<span class="fc bfc" id="L175" title="All 2 branches covered.">            if (hasHeaderSeparator(line)) {</span>
<span class="fc" id="L176">                LOGGER.debug(&quot;Header separator found&quot;);</span>
<span class="fc" id="L177">                break;</span>
            }
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (isTypeProperty(line)) {</span>
<span class="fc" id="L180">                LOGGER.debug(&quot;Type property found&quot;);</span>
<span class="fc" id="L181">                typeFound = true;</span>
            }

<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (isStatusProperty(line)) {</span>
<span class="fc" id="L185">                LOGGER.debug(&quot;Status property found&quot;);</span>
<span class="fc" id="L186">                statusFound = true;</span>
            }
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">            if (!line.isEmpty() &amp;&amp; !line.contains(&quot;=&quot;)) {</span>
<span class="nc" id="L189">                LOGGER.error(&quot;Property found without assignment [{}]&quot;, line);</span>
<span class="nc" id="L190">                headerValid = false;</span>
            }
<span class="fc" id="L192">        }</span>
<span class="pc bpc" id="L193" title="1 of 10 branches missed.">        return headerValid &amp;&amp; (statusFound || hasDefaultStatus()) &amp;&amp; (typeFound || hasDefaultType());</span>
    }

    private boolean hasDefaultType() {
<span class="fc bfc" id="L197" title="All 2 branches covered.">        return !configuration.getDefaultType().isEmpty();</span>
    }

    private boolean hasDefaultStatus() {
<span class="fc bfc" id="L201" title="All 2 branches covered.">        return !configuration.getDefaultStatus().isEmpty();</span>
    }

    private boolean hasHeaderSeparatorInContent(List&lt;String&gt; contents) {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        return contents.indexOf(configuration.getHeaderSeparator()) != -1;</span>
    }

    /**
     * Checks if header separator demarcates end of metadata header
     *
     * @param contents
     * @return true if header separator resides at end of metadata header, false if not
     */
    private boolean headerSeparatorDemarcatesHeader(List&lt;String&gt; contents) {
<span class="fc" id="L215">        List&lt;String&gt; subContents = null;</span>
<span class="fc" id="L216">        int index = contents.indexOf(configuration.getHeaderSeparator());</span>
<span class="fc bfc" id="L217" title="All 2 branches covered.">        if (index != -1) {</span>
            // get every line above header separator
<span class="fc" id="L219">            subContents = contents.subList(0, index);</span>

<span class="fc bfc" id="L221" title="All 2 branches covered.">            for (String line : subContents) {</span>
                // header should only contain empty lines or lines with '=' in
<span class="fc bfc" id="L223" title="All 4 branches covered.">                if (!line.contains(&quot;=&quot;) &amp;&amp; !line.isEmpty())  {</span>
<span class="fc" id="L224">                    return false;</span>
                }
<span class="fc" id="L226">            }</span>
<span class="fc" id="L227">            return true;</span>
        } else {
<span class="fc" id="L229">            return false;</span>
        }
    }

    private boolean hasHeaderSeparator(String line) {
<span class="fc" id="L234">        return line.equals(configuration.getHeaderSeparator());</span>
    }

    private boolean isStatusProperty(String line) {
<span class="fc" id="L238">        return line.startsWith(&quot;status=&quot;);</span>
    }

    private boolean isTypeProperty(String line) {
<span class="fc" id="L242">        return line.startsWith(&quot;type=&quot;);</span>
    }

    /**
     * Process the header of the file.
     *
     * @param context the parser context
     */
    private void processDefaultHeader(ParserContext context) {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        for (String line : context.getFileLines()) {</span>

<span class="fc bfc" id="L253" title="All 2 branches covered.">            if (hasHeaderSeparator(line)) {</span>
<span class="fc" id="L254">                break;</span>
            }
<span class="fc" id="L256">            processHeaderLine(line, context.getDocumentModel());</span>
<span class="fc" id="L257">        }</span>
<span class="fc" id="L258">    }</span>

    private void processHeaderLine(String line, Map&lt;String, Object&gt; content) {
<span class="fc" id="L261">        String[] parts = line.split(&quot;=&quot;, 2);</span>
<span class="pc bpc" id="L262" title="2 of 4 branches missed.">        if (!line.isEmpty() &amp;&amp; parts.length == 2) {</span>
<span class="fc" id="L263">            storeHeaderValue(parts[0], parts[1], content);</span>
        }
<span class="fc" id="L265">    }</span>

    void storeHeaderValue(String inputKey, String inputValue, Map&lt;String, Object&gt; content) {
<span class="fc" id="L268">        String key = sanitizeKey(inputKey);</span>
<span class="fc" id="L269">        String value = sanitizeValue(inputValue);</span>

<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (key.equalsIgnoreCase(Crawler.Attributes.DATE)) {</span>
<span class="fc" id="L272">            DateFormat df = new SimpleDateFormat(configuration.getDateFormat());</span>
            try {
<span class="fc" id="L274">                Date date = df.parse(value);</span>
<span class="fc" id="L275">                content.put(key, date);</span>
<span class="nc" id="L276">            } catch (ParseException e) {</span>
<span class="nc" id="L277">                LOGGER.error(&quot;unable to parse date {}&quot;, value);</span>
<span class="fc" id="L278">            }</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        } else if (key.equalsIgnoreCase(Crawler.Attributes.TAGS)) {</span>
<span class="fc" id="L280">            content.put(key, getTags(value));</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">        } else if (isJson(value)) {</span>
<span class="fc" id="L282">            content.put(key, JSONValue.parse(value));</span>
        } else {
<span class="fc" id="L284">            content.put(key, value);</span>
        }
<span class="fc" id="L286">    }</span>

    private String sanitizeValue(String part) {
<span class="fc" id="L289">        return part.trim();</span>
    }

    private String sanitizeKey(String part) {
        String key;
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (part.contains(UTF_8_BOM)) {</span>
<span class="nc" id="L295">            key = part.trim().replace(UTF_8_BOM, &quot;&quot;);</span>
        } else {
<span class="fc" id="L297">            key = part.trim();</span>
        }
<span class="fc" id="L299">        return key;</span>
    }

    private String[] getTags(String tagsPart) {
<span class="fc" id="L303">        String[] tags = tagsPart.split(&quot;,&quot;);</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">        for (int i = 0; i &lt; tags.length; i++)</span>
<span class="fc" id="L305">            tags[i] = sanitizeValue(tags[i]);</span>
<span class="fc" id="L306">        return tags;</span>
    }

    private boolean isJson(String part) {
<span class="pc bpc" id="L310" title="1 of 4 branches missed.">        return part.startsWith(&quot;{&quot;) &amp;&amp; part.endsWith(&quot;}&quot;);</span>
    }

    /**
     * Process the body of the file.
     *
     * @param context the parser context
     */
    private void processDefaultBody(ParserContext context) {
<span class="fc" id="L319">        StringBuilder body = new StringBuilder();</span>
<span class="fc" id="L320">        boolean inBody = false;</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">        for (String line : context.getFileLines()) {</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">            if (inBody) {</span>
<span class="fc" id="L323">                body.append(line).append(&quot;\n&quot;);</span>
            }
<span class="fc bfc" id="L325" title="All 2 branches covered.">            if (line.equals(configuration.getHeaderSeparator())) {</span>
<span class="fc" id="L326">                inBody = true;</span>
            }
<span class="fc" id="L328">        }</span>

<span class="fc bfc" id="L330" title="All 2 branches covered.">        if (body.length() == 0) {</span>
<span class="fc bfc" id="L331" title="All 2 branches covered.">            for (String line : context.getFileLines()) {</span>
<span class="fc" id="L332">                body.append(line).append(&quot;\n&quot;);</span>
<span class="fc" id="L333">            }</span>
        }
<span class="fc" id="L335">        context.setBody(body.toString());</span>
<span class="fc" id="L336">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>